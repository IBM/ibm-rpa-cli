using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace Joba.IBM.RPA.Cli
{
    internal class GitConfigurator
    {
        private readonly ILogger logger;
        private readonly DirectoryInfo workingDir;

        public GitConfigurator(ILogger logger, DirectoryInfo workingDir)
        {
            this.logger = logger;
            this.workingDir = workingDir;
            var gitDir = new DirectoryInfo(Path.Combine(workingDir.FullName, ".git"));
            if (!gitDir.Exists)
                throw new DirectoryNotFoundException($"Git is not initialized in '{workingDir.FullName}' directory.");
        }

        internal async Task ConfigureAsync(CancellationToken cancellation)
        {
            var gitAttributes = new GitAttributes(workingDir);
            await gitAttributes.ConfigurePatternAsync(cancellation);

            var diffConfigurator = new DiffConfigurator(logger);
            await diffConfigurator.CreateConversionWrapperAsync(cancellation);
            await diffConfigurator.ConfigureAsync(cancellation);

            var mergeConfigurator = new MergeConfigurator(logger);
            await mergeConfigurator.ConfigureAsync(cancellation);
        }

        internal async Task RemoveAsync(CancellationToken cancellation)
        {
            var gitAttributes = new GitAttributes(workingDir);
            await gitAttributes.RemovePatternAsync(cancellation);

            var diffConfigurator = new DiffConfigurator(logger);
            await diffConfigurator.DeleteAsync(cancellation);

            var mergeConfigurator = new MergeConfigurator(logger);
            await mergeConfigurator.DeleteAsync(cancellation);
        }

        internal class GitAttributes
        {
            private const string FileName = ".gitattributes";
            private const string Comment = $"# DO NOT EDIT next line - auto-generated by '{RpaCommand.ServiceName}'";
            private const string Pattern = $"*{WalFile.Extension} diff={RpaCommand.CommandName} merge={RpaCommand.CommandName}";
            private readonly FileInfo file;

            internal GitAttributes(DirectoryInfo workingDir)
                : this(new FileInfo(Path.Combine(workingDir.FullName, FileName))) { }

            internal GitAttributes(FileInfo file) => this.file = file;

            /// <summary>
            /// Configures .gitattributes to tell git to call 'rpa git diff' through the conversion wrapper <see cref="DiffConfigurator"/>.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            internal async Task ConfigurePatternAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    await CreateFileAsync(cancellation);
                else
                {
                    var found = false;
                    var skipNext = false;
                    var lines = new List<string>();
                    await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                    {
                        if (line.Equals(Comment))
                        {
                            lines.Add(line); //add the comment line
                            lines.Add(Pattern); //add the pattern line
                            found = true;
                            skipNext = true;
                        }
                        else
                        {
                            //if the previous line was the 'found line', then skip the next line if it has text.
                            if (skipNext == true && !string.IsNullOrEmpty(line))
                            {
                                skipNext = false;
                                continue;
                            }
                            lines.Add(line);
                        }
                    }

                    if (!found)
                    {
                        lines.Add(string.Empty); //add new empty line
                        lines.Add(Comment);
                        lines.Add(Pattern);
                    }

                    await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
                }
            }

            internal async Task RemovePatternAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    return;

                var lines = new List<string>();
                await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                {
                    if (!line.Equals(Comment) && !line.Equals(Pattern))
                        lines.Add(line);
                }

                await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
            }

            private async Task CreateFileAsync(CancellationToken cancellation)
            {
                var contents = new StringBuilder();
                contents.AppendLine(Comment);
                contents.AppendLine(Pattern);

                await File.WriteAllTextAsync(file.FullName, contents.ToString(), cancellation);
            }
        }

        internal class DiffConfigurator
        {
            private readonly FileInfo file;
            private readonly ILogger logger;

            public DiffConfigurator(ILogger logger)
            {
                this.logger = logger;
                file = new FileInfo(Path.Combine(System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData), RpaCommand.CommandName, "wal2txt"));
            }

            internal string Name => file.Name;
            internal DirectoryInfo Directory => file.Directory!;

            /// <summary>
            /// Provides an intermediate file that tells git how to call 'rpa git diff [fileName]', since git does not know how to call that directly.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            internal async Task CreateConversionWrapperAsync(CancellationToken cancellation)
            {
                file.Directory!.Create();
                await File.WriteAllTextAsync(file.FullName, GetContents(), cancellation);
                AppendToPathEnvironmentVariable();
            }

            private static string GetContents() => $"#!/bin/bash" + System.Environment.NewLine +
                    $"{RpaCommand.CommandName} {GitCommand.CommandName} {GitCommand.DiffCommand.CommandName} \"$1\"";

            /// <summary>
            /// The directory where the 'wal2txt' (conversion intermediate file) file is located needs to be in the windows environment PATH so git can reach it.
            /// </summary>
            private void AppendToPathEnvironmentVariable()
            {
                var current = System.Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User) ?? string.Empty;
                var variables = current.Split(';');
                if (Array.IndexOf(variables, Directory.FullName) < 0)
                {
                    current = $"{current};{Directory.FullName}";
                    System.Environment.SetEnvironmentVariable("PATH", current, EnvironmentVariableTarget.User);
                }
            }

            private void RemoveFromPathEnvironmentVariable()
            {
                var current = System.Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User) ?? string.Empty;
                var variables = current.Split(';').ToList();
                var removed = variables.Remove(Directory.FullName);
                if (removed)
                {
                    current = string.Join(';', variables);
                    System.Environment.SetEnvironmentVariable("PATH", current, EnvironmentVariableTarget.User);
                }
            }

            /// <summary>
            /// Tells git to use the wrapper file by issuing a 'git config [params]' command.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            /// <exception cref="Exception"></exception>
            internal async Task ConfigureAsync(CancellationToken cancellation)
            {
                if (await NeedsConfigurationAsync(cancellation))
                {
                    await ConfigureTextConversionAsync(cancellation);
                    await ConfigureCacheTextConversionAsync(cancellation);
                }
            }

            private async Task<bool> NeedsConfigurationAsync(CancellationToken cancellation)
            {
                var info = new ProcessStartInfo("git", $"config --global --get-regexp diff.{RpaCommand.CommandName}.*") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                using var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                await process.WaitForExitAsync(cancellation);

                return string.IsNullOrWhiteSpace(output) == false;
            }

            private async Task ConfigureTextConversionAsync(CancellationToken cancellation)
            {
                var info = new ProcessStartInfo("git", $"config --global diff.{RpaCommand.CommandName}.textconv {Name}") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);
            }

            private async Task ConfigureCacheTextConversionAsync(CancellationToken cancellation)
            {
                var info = new ProcessStartInfo("git", $"config --global diff.{RpaCommand.CommandName}.cachetextconv true") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);
            }

            private void OnGitError(object sender, DataReceivedEventArgs e)
            {
                if (!string.IsNullOrEmpty(e.Data))
                    logger.LogError($"Git error: {e.Data}");
            }

            internal async Task DeleteAsync(CancellationToken cancellation)
            {
                if (file.Exists)
                    file.Delete();

                var info = new ProcessStartInfo("git", $"config --global --remove-section diff.{RpaCommand.CommandName}") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);

                RemoveFromPathEnvironmentVariable();
            }
        }

        internal class MergeConfigurator
        {
            private readonly ILogger logger;

            internal MergeConfigurator(ILogger logger)
            {
                this.logger = logger;
            }

            internal async Task ConfigureAsync(CancellationToken cancellation)
            {
                if (await NeedsConfigurationAsync(cancellation))
                    await ConfigureMergeDriverAsync(cancellation);
            }

            private async Task<bool> NeedsConfigurationAsync(CancellationToken cancellation)
            {
                var info = new ProcessStartInfo("git", $"config --global --get-regexp merge.{RpaCommand.CommandName}.*") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                using var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                await process.WaitForExitAsync(cancellation);

                return string.IsNullOrWhiteSpace(output) == false;
            }

            private async Task ConfigureMergeDriverAsync(CancellationToken cancellation)
            {
                /* 
                 * [merge "driver-name"]
	                 name = readable driver name
	                 driver = command-line %O %A %B %L %P
                 * %O = ancestor’s version (original commit or the base commit - BASE)
                 * %A = current version (our commit from the current branch - OURS)
                 * %B = the other branches' version (the commit for the other branch - THEIRS)
                 * %L = will be replaced with the conflict marker size (https://git-scm.com/docs/gitattributes#_conflict_marker_size)
                 * %P = the merge driver can learn the pathname in which the merged result will be stored
                 */

                await ConfigureNameAsync(cancellation);
                await ConfigureDriverAsync(cancellation);
                await ConfigureRecursiveAsync(cancellation);

                async Task ConfigureNameAsync(CancellationToken cancellation)
                {
                    var info = new ProcessStartInfo("git", $"config --global merge.{RpaCommand.CommandName}.name \"rpa cli merge driver\"") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                    var process = Process.Start(info);
                    if (process == null)
                        throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                    process.ErrorDataReceived += OnGitError;
                    process.BeginErrorReadLine();
                    var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                    if (!string.IsNullOrEmpty(output))
                        logger.LogInformation("Git output: {Output}", output);
                    await process.WaitForExitAsync(cancellation);
                }

                async Task ConfigureDriverAsync(CancellationToken cancellation)
                {
                    var info = new ProcessStartInfo("git", $"config --global merge.{RpaCommand.CommandName}.driver \"{RpaCommand.CommandName} {GitCommand.CommandName} {GitCommand.MergeCommand.CommandName} %O %A %B\"") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                    var process = Process.Start(info);
                    if (process == null)
                        throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                    process.ErrorDataReceived += OnGitError;
                    process.BeginErrorReadLine();
                    var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                    if (!string.IsNullOrEmpty(output))
                        logger.LogInformation("Git output: {Output}", output);
                    await process.WaitForExitAsync(cancellation);
                }

                async Task ConfigureRecursiveAsync(CancellationToken cancellation)
                {
                    var info = new ProcessStartInfo("git", $"config --global merge.{RpaCommand.CommandName}.recursive text") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                    var process = Process.Start(info);
                    if (process == null)
                        throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                    process.ErrorDataReceived += OnGitError;
                    process.BeginErrorReadLine();
                    var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                    if (!string.IsNullOrEmpty(output))
                        logger.LogInformation("Git output: {Output}", output);
                    await process.WaitForExitAsync(cancellation);
                }
            }

            private void OnGitError(object sender, DataReceivedEventArgs e)
            {
                if (!string.IsNullOrEmpty(e.Data))
                    logger.LogError($"Git error: {e.Data}");
            }

            internal async Task DeleteAsync(CancellationToken cancellation)
            {
                var info = new ProcessStartInfo("git", $"config --global --remove-section merge.{RpaCommand.CommandName}") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);
            }
        }
    }
}

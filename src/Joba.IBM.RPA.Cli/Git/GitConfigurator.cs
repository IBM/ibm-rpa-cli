using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace Joba.IBM.RPA.Cli
{
    internal class GitConfigurator
    {
        private readonly ILogger logger;
        private readonly DirectoryInfo workingDir;

        public GitConfigurator(ILogger logger, DirectoryInfo workingDir)
        {
            this.logger = logger;
            this.workingDir = workingDir;
            var gitDir = new DirectoryInfo(Path.Combine(workingDir.FullName, ".git"));
            if (!gitDir.Exists)
                throw new DirectoryNotFoundException($"Git is not initialized in '{workingDir.FullName}' directory.");
        }

        internal async Task ConfigureAsync(CancellationToken cancellation)
        {
            var gitAttributes = new GitAttributes(workingDir);
            await gitAttributes.ConfigurePatternAsync(cancellation);

            var walToTxtWrapper = new ConversionWrapper(logger);
            await walToTxtWrapper.CreateAsync(cancellation);
            await walToTxtWrapper.ConfigureAsync(cancellation);
        }

        internal async Task RemoveAsync(CancellationToken cancellation)
        {
            var gitAttributes = new GitAttributes(workingDir);
            await gitAttributes.RemovePatternAsync(cancellation);

            var walToTxtWrapper = new ConversionWrapper(logger);
            await walToTxtWrapper.DeleteAsync(cancellation);
        }

        internal class GitAttributes
        {
            private const string FileName = ".gitattributes";
            private const string Comment = $"# DO NOT EDIT next line - auto-generated by '{RpaCommand.ServiceName}'";
            private readonly FileInfo file;

            internal GitAttributes(DirectoryInfo workingDir)
                : this(new FileInfo(Path.Combine(workingDir.FullName, FileName))) { }

            internal GitAttributes(FileInfo file) => this.file = file;

            /// <summary>
            /// Configures .gitattributes to tell git to call 'rpa git diff' through the conversion wrapper <see cref="ConversionWrapper"/>.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            internal async Task ConfigurePatternAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    await CreateFileAsync(cancellation);
                else
                {
                    var found = false;
                    var skipNext = false;
                    var lines = new List<string>();
                    await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                    {
                        if (line.Equals(Comment))
                        {
                            lines.Add(line); //add the comment line
                            lines.Add($"*{WalFile.Extension} diff={RpaCommand.CommandName}"); //add the pattern line
                            found = true;
                            skipNext = true;
                        }
                        else
                        {
                            //if the previous line was the 'found line', then skip the next line if it has text.
                            if (skipNext == true && !string.IsNullOrEmpty(line))
                            {
                                skipNext = false;
                                continue;
                            }
                            lines.Add(line);
                        }
                    }

                    if (!found)
                    {
                        lines.Add(string.Empty); //add new empty line
                        lines.Add(Comment);
                        lines.Add($"*{WalFile.Extension} diff={RpaCommand.CommandName}");
                    }

                    await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
                }
            }

            internal async Task RemovePatternAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    return;

                var lines = new List<string>();
                await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                {
                    if (!line.Equals(Comment) && !line.Equals($"*{WalFile.Extension} diff={RpaCommand.CommandName}"))
                        lines.Add(line);
                }

                await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
            }

            private async Task CreateFileAsync(CancellationToken cancellation)
            {
                var contents = new StringBuilder();
                contents.AppendLine(Comment);
                contents.AppendLine($"*{WalFile.Extension} diff={RpaCommand.CommandName}");

                await File.WriteAllTextAsync(file.FullName, contents.ToString(), cancellation);
            }
        }

        /// <summary>
        /// Provides an intermediate file that tells git how to call 'rpa git diff [fileName]', since git does not know how to call that directly.
        /// </summary>
        internal class ConversionWrapper
        {
            private readonly FileInfo file;
            private readonly ILogger logger;

            public ConversionWrapper(ILogger logger)
            {
                this.logger = logger;
                file = new FileInfo(Path.Combine(System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData), RpaCommand.CommandName, "wal2txt"));
            }

            internal string Name => file.Name;
            internal DirectoryInfo Directory => file.Directory!;

            /// <summary>
            /// Creates the wrapper conversion file.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            internal async Task CreateAsync(CancellationToken cancellation)
            {
                file.Directory!.Create();
                await File.WriteAllTextAsync(file.FullName, GetContents(), cancellation);
                AppendToPathEnvironmentVariable();
            }

            private static string GetContents() => $"#!/bin/bash" + System.Environment.NewLine +
                    $"{RpaCommand.CommandName} {GitCommand.CommandName} {GitCommand.DiffCommand.CommandName} \"$1\"";

            /// <summary>
            /// The directory where <see cref="ConversionWrapper"/> file is located needs to be in the windows environment PATH so git can reach it.
            /// </summary>
            private void AppendToPathEnvironmentVariable()
            {
                var current = System.Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User) ?? string.Empty;
                var variables = current.Split(';');
                if (Array.IndexOf(variables, Directory.FullName) < 0)
                {
                    current = $"{current};{Directory.FullName}";
                    System.Environment.SetEnvironmentVariable("PATH", current, EnvironmentVariableTarget.User);
                }
            }

            private void RemoveFromPathEnvironmentVariable()
            {
                var current = System.Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User) ?? string.Empty;
                var variables = current.Split(';').ToList();
                var removed = variables.Remove(Directory.FullName);
                if (removed)
                {
                    current = string.Join(';', variables);
                    System.Environment.SetEnvironmentVariable("PATH", current, EnvironmentVariableTarget.User);
                }
            }

            /// <summary>
            /// Tells git to use the wrapper file by issuing a 'git config [params]' command.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            /// <exception cref="Exception"></exception>
            internal async Task ConfigureAsync(CancellationToken cancellation)
            {
                if (await NeedsConfigurationAsync(cancellation))
                {
                    var info = new ProcessStartInfo("git", $"config --global diff.{RpaCommand.CommandName}.textconv {Name}") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                    using var process = Process.Start(info);
                    if (process == null)
                        throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                    process.ErrorDataReceived += OnGitError;
                    process.BeginErrorReadLine();
                    var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                    if (!string.IsNullOrEmpty(output))
                        logger.LogInformation("Git output: {Output}", output);
                    await process.WaitForExitAsync(cancellation);
                }
            }

            private async Task<bool> NeedsConfigurationAsync(CancellationToken cancellation)
            {
                var needsConfiguration = true;
                var info = new ProcessStartInfo("git", $"config --global --get diff.{RpaCommand.CommandName}.textconv") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                using var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                needsConfiguration = output.Trim().TrimEnd('\n', '\r') != Name;
                await process.WaitForExitAsync(cancellation);

                return needsConfiguration;
            }

            private void OnGitError(object sender, DataReceivedEventArgs e)
            {
                if (!string.IsNullOrEmpty(e.Data))
                    logger.LogError($"Git error: {e.Data}");
            }

            internal async Task DeleteAsync(CancellationToken cancellation)
            {
                if (file.Exists)
                    file.Delete();

                var info = new ProcessStartInfo("git", $"config --global --unset diff.{RpaCommand.CommandName}.textconv") { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                using var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);

                RemoveFromPathEnvironmentVariable();
            }
        }
    }
}

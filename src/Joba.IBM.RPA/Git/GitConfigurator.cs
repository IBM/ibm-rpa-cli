using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace Joba.IBM.RPA
{
    public class GitConfigurator
    {
        private readonly ILogger logger;
        private readonly DirectoryInfo workingDir;
        private readonly string cliName;
        private readonly string gitDiffCommandLine;
        private readonly string gitMergeCommandLine;

        public GitConfigurator(ILogger logger, DirectoryInfo workingDir, string cliName, string gitDiffCommandLine, string gitMergeCommandLine)
        {
            this.logger = logger;
            this.workingDir = workingDir;
            this.cliName = cliName;
            this.gitDiffCommandLine = gitDiffCommandLine;
            this.gitMergeCommandLine = gitMergeCommandLine;
            var gitDir = new DirectoryInfo(Path.Combine(workingDir.FullName, ".git"));
            if (!gitDir.Exists)
                throw new DirectoryNotFoundException($"Git is not initialized in '{workingDir.FullName}' directory.");
        }

        public async Task ConfigureAsync(CancellationToken cancellation)
        {
            var gitAttributes = new GitAttributes(workingDir, cliName);
            await gitAttributes.ConfigureAsync(cancellation);

            var gitIgnore = new GitIgnore(workingDir,cliName);
            await gitIgnore.ConfigureAsync(cancellation);

            var diffConfigurator = new DiffConfigurator(logger, cliName, gitDiffCommandLine);
            await diffConfigurator.CreateConversionWrapperAsync(cancellation);
            await diffConfigurator.ConfigureAsync(cancellation);

            var mergeConfigurator = new MergeConfigurator(logger, cliName, gitMergeCommandLine);
            await mergeConfigurator.ConfigureAsync(cancellation);
        }

        public async Task RemoveAsync(CancellationToken cancellation)
        {
            var mergeConfigurator = new MergeConfigurator(logger, cliName, gitMergeCommandLine);
            await mergeConfigurator.DeleteAsync(cancellation);

            var diffConfigurator = new DiffConfigurator(logger, cliName, gitDiffCommandLine);
            await diffConfigurator.DeleteAsync(cancellation);

            var gitIgnore = new GitIgnore(workingDir, cliName);
            await gitIgnore.RemoveAsync(cancellation);

            var gitAttributes = new GitAttributes(workingDir, cliName);
            await gitAttributes.RemoveAsync(cancellation);
        }

        internal class GitAttributes
        {
            private const string FileName = ".gitattributes";
            private readonly FileInfo file;
            private readonly string pattern;
            private readonly string comment;

            internal GitAttributes(DirectoryInfo workingDir, string cliName)
                : this(new FileInfo(Path.Combine(workingDir.FullName, FileName)), cliName) { }
            internal GitAttributes(FileInfo file, string cliName)
            {
                this.file = file;
                pattern = $"*{WalFile.Extension} diff={cliName} merge={cliName}";
                comment = $"# DO NOT EDIT next line - auto-generated by '{cliName}'";
            }

            /// <summary>
            /// Configures .gitattributes to tell git to call 'rpa git diff' through the conversion wrapper <see cref="DiffConfigurator"/>.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            internal async Task ConfigureAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    await CreateFileAsync(cancellation);
                else
                {
                    var found = false;
                    var skipNext = false;
                    var lines = new List<string>();
                    await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                    {
                        if (line.Equals(comment))
                        {
                            lines.Add(line); //add the comment line
                            lines.Add(pattern); //add the pattern line
                            found = true;
                            skipNext = true;
                        }
                        else
                        {
                            //if the previous line was the 'found line', then skip the next line if it has text.
                            if (skipNext == true && !string.IsNullOrEmpty(line))
                            {
                                skipNext = false;
                                continue;
                            }
                            lines.Add(line);
                        }
                    }

                    if (!found)
                    {
                        lines.Add(string.Empty); //add new empty line
                        lines.Add(comment);
                        lines.Add(pattern);
                    }

                    await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
                }
            }

            internal async Task RemoveAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    return;

                var lines = new List<string>();
                await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                {
                    if (!line.Equals(comment) && !line.Equals(pattern))
                        lines.Add(line);
                }

                await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
            }

            private async Task CreateFileAsync(CancellationToken cancellation)
            {
                var contents = new StringBuilder();
                contents.AppendLine(comment);
                contents.AppendLine(pattern);

                await File.WriteAllTextAsync(file.FullName, contents.ToString(), cancellation);
            }
        }

        internal class DiffConfigurator
        {
            private readonly FileInfo file;
            private readonly ILogger logger;
            private readonly string cliName;
            private readonly string gitDiffCommandLine;

            public DiffConfigurator(ILogger logger, string cliName, string gitDiffCommandLine)
            {
                this.logger = logger;
                this.cliName = cliName;
                this.gitDiffCommandLine = gitDiffCommandLine;
                file = new FileInfo(Path.Combine(System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData), cliName, "wal2txt"));
            }

            internal string Name => file.Name;
            internal DirectoryInfo Directory => file.Directory!;

            /// <summary>
            /// Provides an intermediate file that tells git how to call 'rpa git diff [fileName]', since git does not know how to call that directly.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            internal async Task CreateConversionWrapperAsync(CancellationToken cancellation)
            {
                file.Directory!.Create();
                await File.WriteAllTextAsync(file.FullName, GetContents(), cancellation);
                AppendToPathEnvironmentVariable();
            }

            private string GetContents() => $"#!/bin/bash" + System.Environment.NewLine + gitDiffCommandLine;

            /// <summary>
            /// TODO: this is wrong: https://stackoverflow.com/questions/69903900/how-to-maintain-environment-variables-in-path-when-adding-new-path-folder
            /// https://stackoverflow.com/a/9845159/1830639
            /// The directory where the 'wal2txt' (conversion intermediate file) file is located needs to be in the windows environment PATH so git can reach it.
            /// </summary>
            private void AppendToPathEnvironmentVariable()
            {
                var current = System.Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User) ?? string.Empty;
                var variables = current.Split(';');
                if (Array.IndexOf(variables, Directory.FullName) < 0)
                {
                    current = $"{current};{Directory.FullName}";
                    System.Environment.SetEnvironmentVariable("PATH", current, EnvironmentVariableTarget.User);
                }
            }

            private void RemoveFromPathEnvironmentVariable()
            {
                var current = System.Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User) ?? string.Empty;
                var variables = current.Split(';').ToList();
                var removed = variables.Remove(Directory.FullName);
                if (removed)
                {
                    current = string.Join(';', variables);
                    System.Environment.SetEnvironmentVariable("PATH", current, EnvironmentVariableTarget.User);
                }
            }

            /// <summary>
            /// Tells git to use the wrapper file by issuing a 'git config [params]' command.
            /// </summary>
            /// <param name="cancellation"></param>
            /// <returns></returns>
            /// <exception cref="Exception"></exception>
            internal async Task ConfigureAsync(CancellationToken cancellation)
            {
                if (await NeedsConfigurationAsync(cancellation))
                {
                    await ConfigureTextConversionAsync(cancellation);
                    await ConfigureCacheTextConversionAsync(cancellation);
                }
            }

            private async Task<bool> NeedsConfigurationAsync(CancellationToken cancellation)
            {
                var fileName = "git";
                var arguments = $"config --global --get-regexp diff.{cliName}.*";
                logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);
                
                var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                using var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                await process.WaitForExitAsync(cancellation);

                return string.IsNullOrWhiteSpace(output) == true;
            }

            private async Task ConfigureTextConversionAsync(CancellationToken cancellation)
            {
                var fileName = "git";
                var arguments = $"config --global diff.{cliName}.textconv {Name}";
                logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);
            }

            private async Task ConfigureCacheTextConversionAsync(CancellationToken cancellation)
            {
                var fileName = "git";
                var arguments = $"config --global diff.{cliName}.cachetextconv true";
                logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);
            }

            private void OnGitError(object sender, DataReceivedEventArgs e)
            {
                if (!string.IsNullOrEmpty(e.Data))
                    logger.LogError($"Git error: {e.Data}");
            }

            internal async Task DeleteAsync(CancellationToken cancellation)
            {
                if (file.Exists)
                    file.Delete();

                var fileName = "git";
                var arguments = $"config --global --remove-section diff.{cliName}";
                logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);

                RemoveFromPathEnvironmentVariable();
            }
        }

        internal class MergeConfigurator
        {
            private readonly ILogger logger;
            private readonly string cliName;
            private readonly string gitMergeCommandLine;

            internal MergeConfigurator(ILogger logger, string cliName, string gitMergeCommandLine)
            {
                this.logger = logger;
                this.cliName = cliName;
                this.gitMergeCommandLine = gitMergeCommandLine;
            }

            internal async Task ConfigureAsync(CancellationToken cancellation)
            {
                if (await NeedsConfigurationAsync(cancellation))
                    await ConfigureMergeDriverAsync(cancellation);
            }

            private async Task<bool> NeedsConfigurationAsync(CancellationToken cancellation)
            {
                var fileName = "git";
                var arguments = $"config --global --get-regexp merge.{cliName}.*";
                logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                using var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                await process.WaitForExitAsync(cancellation);

                return string.IsNullOrWhiteSpace(output) == true;
            }

            private async Task ConfigureMergeDriverAsync(CancellationToken cancellation)
            {
                /* 
                 * [merge "driver-name"]
	                 name = readable driver name
	                 driver = command-line %O %A %B %L %P
                 * %O = ancestor’s version (original commit or the base commit - BASE)
                 * %A = current version (our commit from the current branch - OURS)
                 * %B = the other branches' version (the commit for the other branch - THEIRS)
                 * %L = will be replaced with the conflict marker size (https://git-scm.com/docs/gitattributes#_conflict_marker_size)
                 * %P = the merge driver can learn the pathname in which the merged result will be stored
                 */

                await ConfigureNameAsync(cancellation);
                await ConfigureDriverAsync(cancellation);
                await ConfigureRecursiveAsync(cancellation);

                async Task ConfigureNameAsync(CancellationToken cancellation)
                {
                    var fileName = "git";
                    var arguments = $"config --global merge.{cliName}.name \"rpa cli merge driver\"";
                    logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                    var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                    var process = Process.Start(info);
                    if (process == null)
                        throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                    process.ErrorDataReceived += OnGitError;
                    process.BeginErrorReadLine();
                    var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                    if (!string.IsNullOrEmpty(output))
                        logger.LogInformation("Git output: {Output}", output);
                    await process.WaitForExitAsync(cancellation);
                }

                async Task ConfigureDriverAsync(CancellationToken cancellation)
                {
                    var fileName = "git";
                    var arguments = $"config --global merge.{cliName}.driver \"{gitMergeCommandLine}\"";
                    logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                    var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                    var process = Process.Start(info);
                    if (process == null)
                        throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                    process.ErrorDataReceived += OnGitError;
                    process.BeginErrorReadLine();
                    var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                    if (!string.IsNullOrEmpty(output))
                        logger.LogInformation("Git output: {Output}", output);
                    await process.WaitForExitAsync(cancellation);
                }

                async Task ConfigureRecursiveAsync(CancellationToken cancellation)
                {
                    var fileName = "git";
                    var arguments = $"config --global merge.{cliName}.recursive text";
                    logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                    var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                    var process = Process.Start(info);
                    if (process == null)
                        throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                    process.ErrorDataReceived += OnGitError;
                    process.BeginErrorReadLine();
                    var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                    if (!string.IsNullOrEmpty(output))
                        logger.LogInformation("Git output: {Output}", output);
                    await process.WaitForExitAsync(cancellation);
                }
            }

            private void OnGitError(object sender, DataReceivedEventArgs e)
            {
                if (!string.IsNullOrEmpty(e.Data))
                    logger.LogError($"Git error: {e.Data}");
            }

            internal async Task DeleteAsync(CancellationToken cancellation)
            {
                var fileName = "git";
                var arguments = $"config --global --remove-section merge.{cliName}";
                logger.LogDebug("Executing {FileName} {Arguments}", fileName, arguments);

                var info = new ProcessStartInfo(fileName, arguments) { UseShellExecute = false, RedirectStandardError = true, RedirectStandardOutput = true };
                var process = Process.Start(info);
                if (process == null)
                    throw new Exception($"Could not start '{info.FileName} {info.Arguments}'");
                process.ErrorDataReceived += OnGitError;
                process.BeginErrorReadLine();
                var output = await process.StandardOutput.ReadToEndAsync(cancellation);
                if (!string.IsNullOrEmpty(output))
                    logger.LogInformation("Git output: {Output}", output);
                await process.WaitForExitAsync(cancellation);
            }
        }

        internal class GitIgnore
        {
            private const string FileName = ".gitignore";
            private readonly FileInfo file;
            private readonly string comment;

            public GitIgnore(DirectoryInfo workingDir, string cliName)
                : this(new FileInfo(Path.Combine(workingDir.FullName, FileName)), cliName) { }
            internal GitIgnore(FileInfo file, string cliName)
            {
                this.file = file;
                comment = $"# DO NOT EDIT next line - auto-generated by '{cliName}'";
            }

            internal async Task ConfigureAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    await CreateFileAsync(cancellation);
                else
                {
                    var found = false;
                    var skips = 0;
                    var lines = new List<string>();
                    var patterns = GetIgnorePatterns();
                    await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                    {
                        if (line.Equals(comment))
                        {
                            lines.Add(line); //add the comment line
                            lines.AddRange(patterns); //add the pattern lines
                            found = true;
                            skips = patterns.Length;
                        }
                        else
                        {
                            //if the previous line was the 'found line', then skip the next 'n' lines if it has text.
                            if (--skips > 0 && !string.IsNullOrEmpty(line))
                                continue;
                            lines.Add(line);
                        }
                    }

                    if (!found)
                    {
                        lines.Add(string.Empty); //add new empty line
                        lines.Add(comment);
                        lines.AddRange(patterns);
                    }

                    await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
                }
            }

            private async Task CreateFileAsync(CancellationToken cancellation)
            {
                var contents = new StringBuilder();
                contents.AppendLine(comment);
                foreach (var pattern in GetIgnorePatterns())
                    contents.AppendLine(pattern);

                await File.WriteAllTextAsync(file.FullName, contents.ToString(), cancellation);
            }

            private static string[] GetIgnorePatterns() => new string[] { ".rpa", "*.wad", "packages" };

            internal async Task RemoveAsync(CancellationToken cancellation)
            {
                if (!file.Exists)
                    return;

                var lines = new List<string>();
                var patterns = GetIgnorePatterns();
                await foreach (var line in File.ReadLinesAsync(file.FullName, cancellation))
                {
                    if (!line.Equals(comment) && !patterns.Contains(line))
                        lines.Add(line);
                }

                await File.WriteAllLinesAsync(file.FullName, lines, cancellation);
            }
        }
    }
}
